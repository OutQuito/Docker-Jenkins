# РОЗДІЛ IV

# Jenkins, Docker, Proxies і Compose

Як поставити NGINX перед Jenkins
Як використовувати Docker Compose для керування набором контейнерів як однієї «Сервісу» та спрощення налаштування
Методи Docker Networking, які дозволяють контейнерам спілкуватися один з одним.

образ Cloudbees Jenkins використовує Debian як ОС за замовчуванням, успадковану від образу Java 8. Але одна з потужних переваг Docker полягає в тому, що ОС може бути якою завгодно, бо хосту байдуже! Це також корисна демонстрація контейнерів у «змішаному режимі», що полягає в тому, що якщо ваша програма охоплює кілька контейнерів, усі вони не обов’язково мають бути однаковими ОС. Це має значення, якщо процеси мають кращу підтримку бібліотек або модулів у певних дистрибутивах Linux. Я дозволю вам вирішити, чи вважаєте ви гарною ідеєю запуск програми, яка має поширення Debian/Centos/Ubuntu. Це просто демонстрація можливостей.

Ви можете змінити це імідж на Ubuntu, Debian або будь-який інший варіант. Я збираюся використовувати CentOS 7, ОС, яка мені знайома. Майте на увазі, якщо ви змінюєте варіанти ОС, вам потрібно буде змінити багато команд/конфігурацій, щоб вони відповідали тому, як NGINX працює в цьому середовищі ОС. 

# I. НАЛАШТУВАННЯ ГОЛОВНОЇ ПАПКИ JENKINS

Коли у нас буде більше одного Dockerfile, ми повинні помістити кожн окремий імідж, яке нам потрібно, у окремий підкаталог. Це означає, що вам потрібно буде перемістити Dockerfile, який ми використовували досі, у новий каталог, який ми назвемо jenkins-master. Переконайтеся, що ви все ще перебуваєте в папці, де він існує. 

    mkdir jenkins-master
    mv Dockerfile jenkins-master

Тепер, коли наш Dockerfile знаходиться в підкаталозі, він не збиратиметься за допомогою команди docker build, яку я вам доручив використовувати, оскільки контекст команди «.» (або поточний каталог). Теоретично ви можете змінити каталог на підкаталог і запустити команду збірки - і це спрацює. Однак я пропоную звикнути до каталогу, де знаходиться ваш файл Dockerfile для додатків із кількома файлами Docker. Простий поворот нашої команди побудови працюватиме так: 

    docker build -t myjenkins jenkins-master/.

# II. СТВОРЕННЯ ФАЙЛУ DOCKER NGINX

NGINX - це веб-сервер та обертка обратного проксі-сервера, яка є однією з найпопулярніших альтернатив Apache. Він широко використовується для обслуговування веб-сайтів, проксі-сервера, стрімінгу мультимедійного вмісту та багато іншого.

Ось деякі ключові особливості та можливості NGINX: 

Висока продуктивність : NGINX відомий своєю високою продуктивністю та ефективним використанням ресурсів. Він розроблений таким чином, щоб забезпечити швидку та ефективну обробку великого обсягу одночасних підключень. 
Обробка запитів : NGINX може обслуговувати статичний та динамічний веб-контент, зокрема HTML-сторінки, зображення, CSS-файли, JavaScript, а також може взаємодіяти з динамічними додатками, написаними на різних мовах програмування.
Проксі-сервер : NGINX може діяти як проксі-сервер, що дозволяє передавати та маршрутизувати запити між клієнтами та різними серверами, забезпечуючи високу доступність та балансування навантаження. 
Статичне стиснення : Вбудована підтримка стиснення gzip дозволяє зменшити розмір вихідних файлів перед їх відправленням клієнтам, що поліпшує швидкість завантаження сторінок. 
Модульна архітектура: NGINX має модульну архітектуру, що дозволяє додавати функціональність за допомогою різних модулів, забезпечуючи гнучкість та можливості налаштування.
Скальованість та надійність: NGINX добре скалюється на великі обсяги трафіку і може бути налаштований для забезпечення високої доступності та надійності в різних умовах.
У загальному, NGINX є потужним та універсальним рішенням для обробки веб-трафіку, яке широко використовується в різних типах проектів та інфраструктурах.

Тепер ми готові створити образ NGINX. У кореневій папці проекту створіть новий каталог під назвою jenkins-nginx, щоб зберігати новий Dockerfile. Тепер у вас має бути два каталоги:

1. jenkins-master
2. jenkins-nginx

У каталозі jenkins-nginx відкрийте новий файл під назвою Dockerfile у бажаному редакторі. Потім виконайте такі дії: 

Встановіть базовий образ ОС, який ви хочете використовувати:

    FROM centos:centos7
    LABEL maintainer=”yourname@somewhere.com”

Використовуйте Yum для встановлення NGINX: 

    RUN yum -y update; yum clean all
    RUN yum -y install http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm; yum -y makecache
    RUN yum -y install nginx-1.10.1

Зверніть увагу, що ми заблокували версію NGINX до 1.10.1. Це лише найкраща практика: завжди виправляйте свої версії, щоб уникнути перескладання вашого образу до неперевіреної версії.

Очистіть файл конфігурації NGINX за замовчуванням, який нам не потрібен: 

    RUN rm /etc/nginx/conf.d/default.conf

Додайте наші конфігураційні файли (їх ще потрібно зробити): 

    COPY conf/jenkins.conf /etc/nginx/conf.d/jenkins.conf
    COPY conf/nginx.conf /etc/nginx/nginx.conf

Це перший раз, коли ми використали команду COPY. Існує також відповідна команда ADD. Для повного ознайомлення з різницею між цими командами я рекомендую ці два посилання:
http://stackoverflow.com/questions/24958140/docker-copy-vs-add
https://docs.docker.com/develop/develop-images/dockerfile_best-practices/
Для нашої мети COPY є найкращим вибором тут. Як зазначено в статтях вище, ми копіюємо окремі файли й не потребуємо функцій ADD (вилучення архіву, пошук на основі URL-адрес тощо). Як ви могли передбачити, у нас будуть деякі оновлення файлу nginx.conf за замовчуванням і певної конфігурації сайту для Jenkins. 

Ми хочемо, щоб NGINX слухав порт 80, тому давайте переконаємося, що цей порт відкритий: 

    EXPOSE 80

Завершіть, переконавшись, що NGINX запущено:

    CMD ["nginx"]

Збережіть файл, але поки не створюйте його! У нас є ці дві команди COPY, тому нам потрібно фактично створити файли, які ми копіюємо, інакше збірка зазнає невдачі, якщо їх не знайде.

# III. СТВОРЕННЯ КОНФІГУРАЦІЇ NGINX

Надаю весь файл nginx.conf тут як приклад, а потім перейду до конкретних змін із файлу nginx.conf за замовчуванням.

    daemon off;
    user  nginx;
    worker_processes  2;

    error_log  /var/log/nginx/error.log warn;
    pid        /var/run/nginx.pid;

    events {
    worker_connections  1024;
    use epoll;
    accept_mutex off;
    }

    http {
    include       /etc/nginx/mime.types;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                        '$status $body_bytes_sent "$http_referer" '
                        '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    client_max_body_size 300m;
    client_body_buffer_size 128k;

    gzip  on;
    gzip_http_version 1.0;
    gzip_comp_level 6;
    gzip_min_length 0;
    gzip_buffers 16 8k;
    gzip_proxied any;
    gzip_types text/plain text/css text/xml text/javascript application/xml application/xml+rss application/javascript application/json;
    gzip_disable "MSIE [1-6]\.";
    gzip_vary on;

    include /etc/nginx/conf.d/*.conf;
    }

Розглянемо зміни за замовчуванням: 

1. Щоб NGINX не запускався як демон:

    daemon off;
    Ми робимо це тому, що за замовчуванням під час виклику nginx у командному рядку NGINX запускається як фоновий демон. Це повертає вихід 0, який змушує Docker вважати, що процес зупинено, тому він вимикає контейнер. Ви побачите, що це часто трапляється з програмами, не призначеними для роботи в контейнерах. На щастя для NGINX, ця проста зміна вирішує проблему без складного обхідного шляху.

2. Збільшення кількості робітників NGINX до 2:

    worker_processes 2;
    Це те, що я роблю з кожним налаштованим NGINX. Ви можете залишити це на 1, якщо хочете. Це дійсно варіант «настроїти, як вважаєте за потрібне». Налаштування NGINX — це окрема тема для публікації. Я не можу сказати вам, що вам підходить. Дуже грубо кажучи, це скільки окремих процесів NGINX у вас є. Кількість ЦП, яку ви виділите, є хорошим орієнтиром. Натовпи спеціалістів NGINX скажуть, що це складніше. Звичайно, всередині контейнера Docker ви можете дискутувати, що тут робити.

3. Налаштування події:

    use epoll;
    accept_mutex off;
    Увімкнення epolling є зручним механізмом налаштування для використання більш ефективних моделей обробки з’єднань. Ми вимикаємо accept_mutex для швидкості, тому що ми не заперечуємо про втрату ресурсів при низькій кількості запитів на з’єднання.

4. Налаштування заголовків проксі:

    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    Це друге налаштування (після вимкнення демона), яке є обов’язковим для проксі-сервера Jenkins. Це встановлює заголовки так, щоб Дженкінс міг правильно інтерпретувати запити, що допомагає усунути деякі попередження про неправильно встановлені заголовки.

5. Клієнтські розміри:

    client_max_body_size 300м;
    client_body_buffer_size 128k;
    Вам це може знадобитися, а може й не знадобитися. Слід визнати, що 300 Мбайт — це великий розмір тіла. Однак у нас є користувачі, які завантажують файли на наш сервер Jenkins — деякі з них є просто плагінами HPI, а інші — справжніми файлами. Ми встановили це, щоб допомогти їм.

6. GZIP на:

    gzip on;
    gzip_http_version 1.0;
    gzip_comp_level 6;
    gzip_min_length 0;
    gzip_buffers 16 8k;
    gzip_proxied any;
    gzip_types text/plain text/css text/xml text/javascript application/xml application/xml+rss application/javascript application/json;
    gzip_disable "MSIE [1-6]\.";
    gzip_vary on;
    Тут ми вмикаємо стиснення gzip для підвищення швидкості.

І це все! Збережіть цей файл і переконайтеся, що він у (в моєму випадку це /home/komarov/Projects/DockerProjects/Jenkins/Section-IV/jenkins-nginx/conf/nginx.conf) conf/nginx.conf там, де його очікує Dockerfile. Наступним кроком буде додавання конкретної конфігурації сайту для Jenkins. 

    mkdir conf

# IV. КОНФІГУРАЦІЯ JENKINS ДЛЯ NGINX

Як і в попередньому розділі, я надам тут повний файл conf, а потім пройдуся по важливим параметрам. Ви можете знайти більшість того, що вам потрібно, у документації Jenkins . Я налаштував файл, оскільки знайшов деякі частини незрозумілими. Ви можете побачити мої тут:

    server {
    listen       80;
    server_name  "";

    access_log off;

    location / {
        proxy_pass         http://jenkins-master:8080;

        proxy_set_header   Host             $host;
        proxy_set_header   X-Real-IP        $remote_addr;
        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
        proxy_set_header   X-Forwarded-Proto http;
        proxy_max_temp_file_size 0;

        proxy_connect_timeout      150;
        proxy_send_timeout         100;
        proxy_read_timeout         100;

        proxy_buffer_size          8k;
        proxy_buffers              4 32k;
        proxy_busy_buffers_size    64k;
        proxy_temp_file_write_size 64k;    

        }

    }

Є лише одне налаштування, яке дійсно має значення для того, що ми тут робимо, і це налаштування проксі-сервера:

    proxy_pass http://jenkins-master:8080; 

(У моєму випадку це може бути proxy_pass http://jenkins-docker:8081;)

Це передбачає існування доменного імені jenkins-master, яке походить від магії мереж Docker (я розгляну це нижче). Якщо ви не використовуєте мережі Docker, це має посилатися на IP-адресу/ім’я хоста, де запущено ваш контейнер Jenkins.

Досить цікаво, що ви не можете встановити це як localhost. Це тому, що кожен контейнер Docker є власним локальним хостом, і він міг би подумати, що ви маєте на увазі хост контейнера NGINX, на якому Jenkins не працює на порту 8080. Щоб уникнути використання мереж Docker, він мав би вказувати на IP-адреса вашого хосту Dockerhost (це має бути ваш комп’ютер/ноутбук, на якому ви працюєте). Хоча ви знаєте цю інформацію, спробуйте уявити, як це складно з’ясувати за допомогою ферми Dockerhosts, де ваш контейнер Jenkins можна розгорнути на будь-якому з них. Вам доведеться написати деяку автоматизацію, щоб отримати IP, а потім відредагувати файл conf. Це можна зробити, але це клопітка. Docker Networks робить це набагато простіше для нас! Щоб дізнатися про неймовірно великі можливості мереж Docker, перегляньте цю початкову статтю(https://docs.docker.com/network/). Не хвилюйтеся, я розповім про основи нижче.

Тепер, коли ми створили файли конфігурації, давайте створимо наш образ NGINX, щоб переконатися, що все працює:

    docker build -t myjenkinsnginx jenkins-nginx/.

######
Монтування прошло успішно без помилок.
######

# V. РОБИМО МЕРЕЖУ DOCKER, ЩОБ NGINX МІГ СПІЛКУВАТИСЯ З JENKINS

Ми хочемо створити мережу між нашими двома контейнерами, щоб вони могли легко знаходити один одного. Однією з причин, чому вони зможуть легко знаходити один одного, є те, що мережі Docker пропонують те, що вони називають «автоматичним виявленням служб». Це дивно для створення імен DNS у мережі, які відповідають іменам контейнерів, які ви створюєте. Ось чому наш конфігураційний файл NGINX посилається на jenkins-master. Docker обробить цей DNS-запис за нас, коли наш контейнер під’єднається до мережі. Це дуже круто – почнемо. 

    docker network create --driver bridge jenkins-net

Назва мережі — jenkins-net. Як мило. Але чому ми використовували драйвер моста? Говорячи простою мовою, ми хочемо «поєднати» ці два контейнери разом. Якщо ви хочете дізнатися більше про всі доступні мережеві драйвери, перегляньте документацію до мережевого драйвера Docker(https://docs.docker.com/network/#network-drivers). Мостова мережа підходить для наших потреб, тому йдемо далі.

Подібно до обсягів даних, переглянути список ваших мереж також легко та інтуїтивно зрозуміло:

    docker network ls

І видалення їх, якщо вам потрібно, також є прогулянкою в парку (вам не потрібно запускати це): 

    docker network rm jenkins-net

# VI. СТВОРЮЄМО ІМІДЖУ NGINX І ЗВ'ЯЗУЄМО ЙОГО З ІМІДЖОМ JENKINS

Зараз у нас є всі необхідні частини. Ми створили наш образ NGINX, і у нас є мережа, до якої ми можемо підключитися. Нам потрібно переконатися, що наші контейнери підключені до мережі. Зупиніть запущений контейнер jenkins-master і видаліть його (не турбуйтеся про свої дані – ми їх зберегли, пам’ятаєте?):

1. docker stop jenkins-master 
2. docker rm jenkins-master

Ми перезапустимо наш головний контейнер Дженкінса, але цього разу приєднаємо його до мережі:

    docker run -p 8080:8080 -p 50000:50000 --name=jenkins-master --network jenkins-net --mount source=jenkins-log,target=/var/log/jenkins --mount source=jenkins-data,target=/var/jenkins_home -d myjenkins

Бачите команду --network jenkins-net? Це все, що потрібно! Наш головний контейнер Jenkins тепер у власній приватній мережі Docker.

Тепер ми нарешті можемо створити контейнер NGINX і підключити його до jenkins-master

    docker build -t myjenkinsnginx jenkins-nginx/.
    docker run -p 80:80 --name=jenkins-nginx --network jenkins-net -d myjenkinsnginx

Зверніть увагу, що порядок запуску тут не має значення. Мережа існує, навіть якщо контейнери не існують, тому будь-який з них може приєднатися в будь-який час. Це може бути дуже корисним для роботи.

Перевірити, чи все працює, дуже просто. Просто введіть у своєму браузері IP-адресу докер-машини, і все має працювати як зазвичай! 

Якщо це не працює, можливо, щось блокує порт 80 на вашому комп’ютері. (Це може статися, особливо в OSX.) Переконайтеся, що ваші брандмауери вимкнено або принаймні приймає трафік через порт 80. Якщо з якоїсь причини ви не можете очистити порт 80, зупиніться та видаліть контейнер jenkins-nginx і повторно запустіть його, але замість цього використовуйте -p 8000:80, щоб зіставити порт 8000 із портом внутрішнього порту 80 контейнера. Потім перейдіть на http://localhost:8000 і подивіться, чи це працює. 

######
Все працює в штатному режимі, проблем ніяких не виявилося.
######

# VII. ОЧИЩЕННЯ ІМІДЖУ JENKINS

Тепер, коли у нас є NGINX, який прослуховує порт 80, нам не потрібен образ або контейнер Дженкінса для доступу до порту 8080. Давайте приберемо цей доступ, видаливши опцію порту під час запуску контейнера. Ми ще раз вимкнемо та перезапустимо. Однак нам не потрібно перезапускати NGINX, оскільки він використовує внутрішній Docker DNS для пошуку jenkins-master у створеній нами мережі jenkins-net.

    docker stop jenkins-master
    docker run -p 50000:50000 --name=jenkins-master --network jenkins-net --mount source=jenkins-log,target=/var/log/jenkins --mount source=jenkins-data,target=/var/jenkins_home -d myjenkins

Оновіть веб-переглядач на http://localhost

Гарно та чисто, а тепер помилкові користувачі навіть не можуть зв’язатися з Jenkins через порт 8080. Натомість вони повинні пройти через ваш проксі-сервер NGINX, щоб отримати його.

Ми дізналися, як налаштувати проксі-сервер NGINX і як використовувати мережі Docker для маршрутизації двох контейнерів разом, що інакше було б дещо незручним у налаштуваннях конфігурації NGINX. Ми також дізналися, що використання іншої базової ОС контейнера в одному з наших контейнерів не впливає на нашу багатоконтейнерну програму.