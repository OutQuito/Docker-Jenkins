# РОЗДІЛ IV

# Jenkins, Docker, Proxies і Compose

Як поставити NGINX перед Jenkins
Як використовувати Docker Compose для керування набором контейнерів як однієї «Сервісу» та спрощення налаштування
Методи Docker Networking, які дозволяють контейнерам спілкуватися один з одним.

образ Cloudbees Jenkins використовує Debian як ОС за замовчуванням, успадковану від образу Java 8. Але одна з потужних переваг Docker полягає в тому, що ОС може бути якою завгодно, бо хосту байдуже! Це також корисна демонстрація контейнерів у «змішаному режимі», що полягає в тому, що якщо ваша програма охоплює кілька контейнерів, усі вони не обов’язково мають бути однаковими ОС. Це має значення, якщо процеси мають кращу підтримку бібліотек або модулів у певних дистрибутивах Linux. Я дозволю вам вирішити, чи вважаєте ви гарною ідеєю запуск програми, яка має поширення Debian/Centos/Ubuntu. Це просто демонстрація можливостей.

Ви можете змінити це імідж на Ubuntu, Debian або будь-який інший варіант. Я збираюся використовувати CentOS 7, ОС, яка мені знайома. Майте на увазі, якщо ви змінюєте варіанти ОС, вам потрібно буде змінити багато команд/конфігурацій, щоб вони відповідали тому, як NGINX працює в цьому середовищі ОС. 

# I. НАЛАШТУВАННЯ ГОЛОВНОЇ ПАПКИ JENKINS

Коли у нас буде більше одного Dockerfile, ми повинні помістити кожн окремий імідж, яке нам потрібно, у окремий підкаталог. Це означає, що вам потрібно буде перемістити Dockerfile, який ми використовували досі, у новий каталог, який ми назвемо jenkins-master. Переконайтеся, що ви все ще перебуваєте в папці, де він існує. 

    mkdir jenkins-master
    mv Dockerfile jenkins-master

Тепер, коли наш Dockerfile знаходиться в підкаталозі, він не збиратиметься за допомогою команди docker build, яку я вам доручив використовувати, оскільки контекст команди «.» (або поточний каталог). Теоретично ви можете змінити каталог на підкаталог і запустити команду збірки - і це спрацює. Однак я пропоную звикнути до каталогу, де знаходиться ваш файл Dockerfile для додатків із кількома файлами Docker. Простий поворот нашої команди побудови працюватиме так: 

    docker build -t myjenkins jenkins-master/.

# II. СТВОРЕННЯ ФАЙЛУ DOCKER NGINX

NGINX - це веб-сервер та обертка обратного проксі-сервера, яка є однією з найпопулярніших альтернатив Apache. Він широко використовується для обслуговування веб-сайтів, проксі-сервера, стрімінгу мультимедійного вмісту та багато іншого.

Ось деякі ключові особливості та можливості NGINX: 

Висока продуктивність: NGINX відомий своєю високою продуктивністю та ефективним використанням ресурсів. Він розроблений таким чином, щоб забезпечити швидку та ефективну обробку великого обсягу одночасних підключень. 
Обробка запитів: NGINX може обслуговувати статичний та динамічний веб-контент, зокрема HTML-сторінки, зображення, CSS-файли, JavaScript, а також може взаємодіяти з динамічними додатками, написаними на різних мовах програмування.
Проксі-сервер: NGINX може діяти як проксі-сервер, що дозволяє передавати та маршрутизувати запити між клієнтами та різними серверами, забезпечуючи високу доступність та балансування навантаження. 
Статичне стиснення: Вбудована підтримка стиснення gzip дозволяє зменшити розмір вихідних файлів перед їх відправленням клієнтам, що поліпшує швидкість завантаження сторінок. 
Модульна архітектура: NGINX має модульну архітектуру, що дозволяє додавати функціональність за допомогою різних модулів, забезпечуючи гнучкість та можливості налаштування.
Скальованість та надійність: NGINX добре скалюється на великі обсяги трафіку і може бути налаштований для забезпечення високої доступності та надійності в різних умовах.
У загальному, NGINX є потужним та універсальним рішенням для обробки веб-трафіку, яке широко використовується в різних типах проектів та інфраструктурах.

Тепер ми готові створити образ NGINX. У кореневій папці проекту створіть новий каталог під назвою jenkins-nginx, щоб зберігати новий Dockerfile. Тепер у вас має бути два каталоги:

1. jenkins-master
2. jenkins-nginx

У каталозі jenkins-nginx відкрийте новий файл під назвою Dockerfile у бажаному редакторі. Потім виконайте такі дії: 

Встановіть базовий образ ОС, який ви хочете використовувати:

    FROM centos:centos7
    LABEL maintainer=”yourname@somewhere.com”

Використовуйте Yum для встановлення NGINX: 

    RUN yum -y update; yum clean all
    RUN yum -y install http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm; yum -y makecache
    RUN yum -y install nginx-1.10.1

Зверніть увагу, що ми заблокували версію NGINX до 1.10.1. Це лише найкраща практика: завжди виправляйте свої версії, щоб уникнути перескладання вашого образу до неперевіреної версії.

Очистіть файл конфігурації NGINX за замовчуванням, який нам не потрібен: 

    RUN rm /etc/nginx/conf.d/default.conf

Додайте наші конфігураційні файли (їх ще потрібно зробити): 

    COPY conf/jenkins.conf /etc/nginx/conf.d/jenkins.conf
    COPY conf/nginx.conf /etc/nginx/nginx.conf

Це перший раз, коли ми використали команду COPY. Існує також відповідна команда ADD. Для повного ознайомлення з різницею між цими командами я рекомендую ці два посилання:
http://stackoverflow.com/questions/24958140/docker-copy-vs-add
https://docs.docker.com/develop/develop-images/dockerfile_best-practices/
Для нашої мети COPY є найкращим вибором тут. Як зазначено в статтях вище, ми копіюємо окремі файли й не потребуємо функцій ADD (вилучення архіву, пошук на основі URL-адрес тощо). Як ви могли передбачити, у нас будуть деякі оновлення файлу nginx.conf за замовчуванням і певної конфігурації сайту для Jenkins. 

Ми хочемо, щоб NGINX слухав порт 80, тому давайте переконаємося, що цей порт відкритий: 

    EXPOSE 80

Завершіть, переконавшись, що NGINX запущено:

    CMD ["nginx"]

Збережіть файл, але поки не створюйте його! У нас є ці дві команди COPY, тому нам потрібно фактично створити файли, які ми копіюємо, інакше збірка зазнає невдачі, якщо їх не знайде.

# III. СТВОРЕННЯ КОНФІГУРАЦІЇ NGINX

Надаю весь файл nginx.conf тут як приклад, а потім перейду до конкретних змін із файлу nginx.conf за замовчуванням.

    daemon off;
    user  nginx;
    worker_processes  2;

    error_log  /var/log/nginx/error.log warn;
    pid        /var/run/nginx.pid;

    events {
    worker_connections  1024;
    use epoll;
    accept_mutex off;
    }

    http {
    include       /etc/nginx/mime.types;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                        '$status $body_bytes_sent "$http_referer" '
                        '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    client_max_body_size 300m;
    client_body_buffer_size 128k;

    gzip  on;
    gzip_http_version 1.0;
    gzip_comp_level 6;
    gzip_min_length 0;
    gzip_buffers 16 8k;
    gzip_proxied any;
    gzip_types text/plain text/css text/xml text/javascript application/xml application/xml+rss application/javascript application/json;
    gzip_disable "MSIE [1-6]\.";
    gzip_vary on;

    include /etc/nginx/conf.d/*.conf;
    }

Розглянемо зміни за замовчуванням: 

1. Щоб NGINX не запускався як демон:

    daemon off

    Ми робимо це тому, що за замовчуванням під час виклику nginx у командному рядку NGINX запускається як фоновий демон. Це повертає вихід 0, який змушує Docker вважати, що процес зупинено, тому він вимикає контейнер. Ви побачите, що це часто трапляється з програмами, не призначеними для роботи в контейнерах. На щастя для NGINX, ця проста зміна вирішує проблему без складного обхідного шляху.

2. Збільшення кількості робітників NGINX до 2:

    worker_processes 2

    Це те, що я роблю з кожним налаштованим NGINX. Ви можете залишити це на 1, якщо хочете. Це дійсно варіант «настроїти, як вважаєте за потрібне». Налаштування NGINX — це окрема тема для публікації. Я не можу сказати вам, що вам підходить. Дуже грубо кажучи, це скільки окремих процесів NGINX у вас є. Кількість ЦП, яку ви виділите, є хорошим орієнтиром. Натовпи спеціалістів NGINX скажуть, що це складніше. Звичайно, всередині контейнера Docker ви можете дискутувати, що тут робити.

3. Налаштування події:

    use epoll
    accept_mutex off

    Увімкнення epolling є зручним механізмом налаштування для використання більш ефективних моделей обробки з’єднань. Ми вимикаємо accept_mutex для швидкості, тому що ми не заперечуємо про втрату ресурсів при низькій кількості запитів на з’єднання.

4. Налаштування заголовків проксі:

    proxy_set_header X-Real-IP $remote_addr
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for

    Це друге налаштування (після вимкнення демона), яке є обов’язковим для проксі-сервера Jenkins. Це встановлює заголовки так, щоб Дженкінс міг правильно інтерпретувати запити, що допомагає усунути деякі попередження про неправильно встановлені заголовки.

5. Клієнтські розміри:

    client_max_body_size 300м
    client_body_buffer_size 128k

    Вам це може знадобитися, а може й не знадобитися. Слід визнати, що 300 Мбайт — це великий розмір тіла. Однак у нас є користувачі, які завантажують файли на наш сервер Jenkins — деякі з них є просто плагінами HPI, а інші — справжніми файлами. Ми встановили це, щоб допомогти їм.

6. GZIP на:

    gzip on
    gzip_http_version 1.0
    gzip_comp_level 6
    gzip_min_length 0
    gzip_buffers 16 8k
    gzip_proxied any
    gzip_types text/plain text/css text/xml text/javascript application/xml application/xml+rss application/javascript application/json
    gzip_disable "MSIE [1-6]\."
    gzip_vary on

    Тут ми вмикаємо стиснення gzip для підвищення швидкості.

І це все! Збережіть цей файл і переконайтеся, що він у (в моєму випадку це /home/komarov/Projects/DockerProjects/Jenkins/Section-IV/jenkins-nginx/conf/nginx.conf) conf/nginx.conf там, де його очікує Dockerfile. Наступним кроком буде додавання конкретної конфігурації сайту для Jenkins. 

    mkdir conf

# IV. КОНФІГУРАЦІЯ JENKINS ДЛЯ NGINX

Як і в попередньому розділі, я надам тут повний файл conf, а потім пройдуся по важливим параметрам. Ви можете знайти більшість того, що вам потрібно, у документації Jenkins . Я налаштував файл, оскільки знайшов деякі частини незрозумілими. Ви можете побачити мої тут:

    server {
    listen       80;
    server_name  "";

    access_log off;

    location / {
        proxy_pass         http://jenkins-master:8080;

        proxy_set_header   Host             $host;
        proxy_set_header   X-Real-IP        $remote_addr;
        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
        proxy_set_header   X-Forwarded-Proto http;
        proxy_max_temp_file_size 0;

        proxy_connect_timeout      150;
        proxy_send_timeout         100;
        proxy_read_timeout         100;

        proxy_buffer_size          8k;
        proxy_buffers              4 32k;
        proxy_busy_buffers_size    64k;
        proxy_temp_file_write_size 64k;    

        }

    }

Є лише одне налаштування, яке дійсно має значення для того, що ми тут робимо, і це налаштування проксі-сервера:

    proxy_pass http://jenkins-master:8080; 

(У моєму випадку це може бути proxy_pass http://jenkins-docker:8081;)

Це передбачає існування доменного імені jenkins-master, яке походить від магії мереж Docker (я розгляну це нижче). Якщо ви не використовуєте мережі Docker, це має посилатися на IP-адресу/ім’я хоста, де запущено ваш контейнер Jenkins.

Досить цікаво, що ви не можете встановити це як localhost. Це тому, що кожен контейнер Docker є власним локальним хостом, і він міг би подумати, що ви маєте на увазі хост контейнера NGINX, на якому Jenkins не працює на порту 8080. Щоб уникнути використання мереж Docker, він мав би вказувати на IP-адреса вашого хосту Dockerhost (це має бути ваш комп’ютер/ноутбук, на якому ви працюєте). Хоча ви знаєте цю інформацію, спробуйте уявити, як це складно з’ясувати за допомогою ферми Dockerhosts, де ваш контейнер Jenkins можна розгорнути на будь-якому з них. Вам доведеться написати деяку автоматизацію, щоб отримати IP, а потім відредагувати файл conf. Це можна зробити, але це клопітка. Docker Networks робить це набагато простіше для нас! Щоб дізнатися про неймовірно великі можливості мереж Docker, перегляньте цю початкову статтю(https://docs.docker.com/network/). Не хвилюйтеся, я розповім про основи нижче.

Тепер, коли ми створили файли конфігурації, давайте створимо наш образ NGINX, щоб переконатися, що все працює:

    docker build -t myjenkinsnginx jenkins-nginx/.

######
Монтування прошло успішно без помилок.
######

# V. РОБИМО МЕРЕЖУ DOCKER, ЩОБ NGINX МІГ СПІЛКУВАТИСЯ З JENKINS

Ми хочемо створити мережу між нашими двома контейнерами, щоб вони могли легко знаходити один одного. Однією з причин, чому вони зможуть легко знаходити один одного, є те, що мережі Docker пропонують те, що вони називають «автоматичним виявленням служб». Це дивно для створення імен DNS у мережі, які відповідають іменам контейнерів, які ви створюєте. Ось чому наш конфігураційний файл NGINX посилається на jenkins-master. Docker обробить цей DNS-запис за нас, коли наш контейнер під’єднається до мережі. Це дуже круто – почнемо. 

    docker network create --driver bridge jenkins-net

Назва мережі — jenkins-net. Як мило. Але чому ми використовували драйвер моста? Говорячи простою мовою, ми хочемо «поєднати» ці два контейнери разом. Якщо ви хочете дізнатися більше про всі доступні мережеві драйвери, перегляньте документацію до мережевого драйвера Docker(https://docs.docker.com/network/#network-drivers). Мостова мережа підходить для наших потреб, тому йдемо далі.

Подібно до обсягів даних, переглянути список ваших мереж також легко та інтуїтивно зрозуміло:

    docker network ls

І видалення їх, якщо вам потрібно, також є прогулянкою в парку (вам не потрібно запускати це): 

    docker network rm jenkins-net

# VI. СТВОРЮЄМО ІМІДЖУ NGINX І ЗВ'ЯЗУЄМО ЙОГО З ІМІДЖОМ JENKINS

Зараз у нас є всі необхідні частини. Ми створили наш образ NGINX, і у нас є мережа, до якої ми можемо підключитися. Нам потрібно переконатися, що наші контейнери підключені до мережі. Зупиніть запущений контейнер jenkins-master і видаліть його (не турбуйтеся про свої дані – ми їх зберегли, пам’ятаєте?):

1. docker stop jenkins-master 
2. docker rm jenkins-master

Ми перезапустимо наш головний контейнер Дженкінса, але цього разу приєднаємо його до мережі:

    docker run -p 8080:8080 -p 50000:50000 --name=jenkins-master --network jenkins-net --mount source=jenkins-log,target=/var/log/jenkins --mount source=jenkins-data,target=/var/jenkins_home -d myjenkins

Бачите команду --network jenkins-net? Це все, що потрібно! Наш головний контейнер Jenkins тепер у власній приватній мережі Docker.

Тепер ми нарешті можемо створити контейнер NGINX і підключити його до jenkins-master

    docker build -t myjenkinsnginx jenkins-nginx/.
    docker run -p 80:80 --name=jenkins-nginx --network jenkins-net -d myjenkinsnginx

Зверніть увагу, що порядок запуску тут не має значення. Мережа існує, навіть якщо контейнери не існують, тому будь-який з них може приєднатися в будь-який час. Це може бути дуже корисним для роботи.

Перевірити, чи все працює, дуже просто. Просто введіть у своєму браузері IP-адресу докер-машини, і все має працювати як зазвичай! 

Якщо це не працює, можливо, щось блокує порт 80 на вашому комп’ютері. (Це може статися, особливо в OSX.) Переконайтеся, що ваші брандмауери вимкнено або принаймні приймає трафік через порт 80. Якщо з якоїсь причини ви не можете очистити порт 80, зупиніться та видаліть контейнер jenkins-nginx і повторно запустіть його, але замість цього використовуйте -p 8000:80, щоб зіставити порт 8000 із портом внутрішнього порту 80 контейнера. Потім перейдіть на http://localhost:8000 і подивіться, чи це працює. 

######
Все працює в штатному режимі, проблем ніяких не виявилося.
######

# VII. ОЧИЩЕННЯ ІМІДЖУ JENKINS

Тепер, коли у нас є NGINX, який прослуховує порт 80, нам не потрібен образ або контейнер Дженкінса для доступу до порту 8080. Давайте приберемо цей доступ, видаливши опцію порту під час запуску контейнера. Ми ще раз вимкнемо та перезапустимо. Однак нам не потрібно перезапускати NGINX, оскільки він використовує внутрішній Docker DNS для пошуку jenkins-master у створеній нами мережі jenkins-net.

    docker stop jenkins-master
    docker run -p 50000:50000 --name=jenkins-master --network jenkins-net --mount source=jenkins-log,target=/var/log/jenkins --mount source=jenkins-data,target=/var/jenkins_home -d myjenkins

Оновіть веб-переглядач на http://localhost

Гарно та чисто, а тепер помилкові користувачі навіть не можуть зв’язатися з Jenkins через порт 8080. Натомість вони повинні пройти через ваш проксі-сервер NGINX, щоб отримати його.

Ми дізналися, як налаштувати проксі-сервер NGINX і як використовувати мережі Docker для маршрутизації двох контейнерів разом, що інакше було б дещо незручним у налаштуваннях конфігурації NGINX. Ми також дізналися, що використання іншої базової ОС контейнера в одному з наших контейнерів не впливає на нашу багатоконтейнерну програму.

# VIII. DOCKER COMPOSE ТА JENKINS

Використання Compose для керування багатоконтейнерною програмою.

Зараз ми використовуємо ідеальну конфігурацію з 2 контейнерів із проксі-контейнером NGINX, контейнером програми Jenkins, нашою власною мережею контейнерів і томами даних для розміщення всіх наших даних Jenkins. Ми виявили, що керування 2 контейнерами, які мають кілька широких опцій щодо мереж і томів, стає дещо складною справою. Docker пропонує ще один зручний інструмент під назвою «Compose». З цією публікацією ми додамо його до суміші. 

ЩО ТАКЕ "COMPOSE"
Compose почав життя як інструмент під назвою Fig. Docker визначає його як «інструмент, призначений для запуску складних програм за допомогою Docker». Повну документацію можна знайти тут: https://docs.docker.com/compose/ . Compose займатиметься створенням наших іміджів і відповідальністю щодо того, що зупиняти та починати під час повторного запуску програми. Це навіть може допомогти нам створити томи даних і мережі, якщо вони ще не існують.

Скажімо, я хочу взяти нашу двоконтейнерну програму, перебудувати контейнер Jenkins і повторно запустити програму – можливо, щоб оновити версію Jenkins. Ось список команд, які мені потрібно буде виконати: 

    docker stop jenkins-master
    docker rm jenkins-master
    docker build -t myjenkins jenkins-master/.
    docker run -p 50000:50000 --name=jenkins-master --network jenkins-net --mount source=jenkins-log,target=/var/log/jenkins --mount source=jenkins-data,target=/var/jenkins_home -d myjenkins

З правельним налаштуванням Compose це виглядає так:

    docker-compose -p jenkins down
    docker-compose build
    docker-compose -p jenkins up -d

Компроміс використання Compose полягає в тому, що вам потрібно підтримувати ще один файл конфігурації разом із файлами Docker.
Я рекомендую це як метод самодокументування залежностей і зв’язків під час запуску, який вписується в загальну екосистему Docker.

    Якщо ви використовуєте Docker для Mac або Docker для Windows, Compose є частиною встановлення за замовчуванням.
    Якщо ви використовуєте Linux, інсталюйте Compose, дотримуючись вказівок тут: https://docs.docker.com/compose/install/

ВАЖЛИВО!!!
У документації Docker згадуються та описуються функції Compose V2.

Починаючи з липня 2023 року, Compose V1 припинив отримувати оновлення, і його більше немає в нових версіях Docker Desktop. Compose V2 замінив його та тепер інтегрований у всі поточні версії Docker Desktop. Для отримання додаткової інформації див Перейдіть на Compose V2 .

КРОК 1. НАЛАШТУВАННЯ ФАЙЛУ КОНФІГУРАЦІЇ COMPOSE

Compose використовує файл конфігурації YAML, що робить його досить простим для читання та розуміння. Нам потрібно додати запис для кожного зображення, яким ми хочемо керувати в Compose, і надати йому особливості.

    У кореневому каталозі проекту створіть новий файл під назвою docker-compose.yml

Ви можете використовувати інше ім’я файлу, але за умовчанням Compose шукатиме це ім’я. 

КРОК 2. ВЕРСІЯ, ТОМИ ТА МЕРЕЖІ

Давайте відредагуємо файл docker-compose.yml і додамо наші базові основи. Спочатку додайте посилання на версію вгорі: 

    version: "3"

Навіщо нам це? Що ж, Docker Compose прожив довге життя протягом трьох поколінь. Це дозволяє Docker Compose знати, що ми використовуємо параметри та API версії 3. Ми використовуємо цю версію, оскільки вона є останньою на момент написання цієї статті.

Далі додамо наші томи: 

    volumes:
     jenkins-data:
     jenkins-log:

Після цього ми можемо додати нашу мережу:

    networks:
     jenkins-net:

Вони не говорять багато, тому що ми використовуємо параметри мережі моста та гучності за замовчуванням, їх просто потрібно оголосити. Наш Compose-файл поки що мало що робить – для цього нам потрібно додати наші зображення.

Кумедний факт! Якщо ви не визначите мережу, Compose автоматично створить для вас мережу. Я вважаю за краще чітко називати свої мережі, тому я все одно створю їх. Насправді Docker Compose створить мережу за замовчуванням для будь-якого контейнера, який її не має (усі контейнери так чи інакше підключаються до мережі). Вам не потрібно турбуватися про це, але ви повинні знати про поведінку. 

КРОК 3. МАСТЕР-ІМІДЖУ JENKINS

Продовжте редагувати файл docker-compose.yml і додайте після volumes наступне:

    services:
     master:
       build: ./jenkins-master
       ports:
         - "50000:50000"
       volumes:
         - jenkins-log:/var/log/jenkins
         - jenkins-data:/var/jenkins_home
       networks:
         - jenkins-net

Спочатку ми додали розділ послуг, де ми визначаємо наші запущені образи та контейнери. Ми додамо імідж NGINX у цей розділ, коли я закінчу пояснювати інші біти.

Потім ми створили головний образ служби (для нашого jenkins-master). Ми дали йому директиву збірки, яка вказує на шлях, де знаходиться наш Dockerfile для jenkins-master. Ми також вказали, які порти слухати.

Потім ми додали потрібні обсяги. Це те саме, що параметри --mount, які ми мали в команді запуску докера. Нарешті ми вказали мережі, у яких хочемо працювати. Пам’ятайте – ми створили томи та мережу в першій частині створення файлу docker-compose.yml.

Compose автоматично обробляє залежності за вас. Якщо ваші мережі або томи не існують, їх буде створено. Він також достатньо розумний, щоб не знищувати їх між зупинками та стартами (або, у номенклатурі Compose, злети та падіння). 

КРОК 4. ІМІДЖ NGINX

Давайте встановимо останню частину. Додайте такі записи в розділ ваших послуг після основного запису:

    nginx:
     build: ./jenkins-nginx
     ports:
        - "80:80"
     networks:
        - jenkins-net

Тут не так багато нового, про що можна говорити. Насправді це трохи простіше, оскільки для нашого сервісу NGINX немає обсягу даних. Збірки та порти працюють однаково. Однак у нас є невелика проблема. Оскільки ми використовуємо Compose, він називатиме наш контейнер jenkins-master відповідно до своїх стандартів іменування. Якщо ви пам’ятаєте, коли ми налаштовували файли конфігурації NGINX, ми посилалися на jenkins-master за назвою у jenkins.conf. У Compose нова назва буде jenkins_master_1. Тому нам потрібно внести зміни. 

Відкрийте файл jenkins.conf у /jenkins-nginx/jenkins.conf.
Відредагуйте рядок, який говорить:

    proxy_pass         http://jenkins-master:8080;

до

    proxy_pass         http://jenkins_master_1:8080;

Збережіть файл.

КРОК 5. ЗʼЄДНУЄМО ВСЕ В ОДНЕ

Тепер нам просто потрібно його побудувати. По-перше, давайте переконаємося, що немає слідів колишніх контейнерів, які використовувалися в попередніх публікаціях. Якщо ви вже очистили, можете пропустити ці кроки.

    docker stop jenkins-nginx
    docker rm jenkins-nginx
    docker stop jenkins-master
    docker rm jenkins-master
    docker volume rm jenkins-data
    docker volume rm jenkins-log
    docker network rm jenkins-net

Ми повинні втратити наші дані та контейнери, щоб перейти до нової моделі. Такий відстій. 

Тепер давайте створювати та запускати за допомогою Compose!

    docker-compose build
    docker-compose -p jenkins up -d

Це воно! Ви побачите, що є параметр -p, оскільки саме тут я даю назву «проекту» Compose, jenkins. Ось чому служби у файлі Compose не згадують jenkins. Docker Compose використовує назву проекту як префікс для всіх контейнерів, які він запускає. Якщо ви не надасте цього, він отримає його з папки, у якій ви перебуваєте, яка може бути будь-що. Використання параметра проекту гарантує послідовність і є найкращою практикою.

Також зверніть увагу на -d, щоб Docker Compose запускав контейнери як демон, як і параметр -d для Docker. Ви помітите, що результат вказує порядок початку та імена. Якщо ви хочете побачити, що працює, Docker Compose також має зручну функцію для цього.

    docker-compose -p jenkins ps

Це дає красиво відформатований список усіх контейнерів програм. Зауважте, що ви все одно повинні дати йому назву проекту, щоб він знав, що шукати! Це допомагає фільтрувати лише контейнери з вашої програми, навіть якщо на хості запущено інші речі. Дуже зручно.

Однак ви, мабуть, помітили, що назви контейнерів не такі, до яких ви звикли. Ви повинні побачити:

    jenkins_master_1
    jenkins_nginx_1

Це стандарт іменування Compose: [проект]_[служба]_[екземпляр]. Ось чому я змусив вас змінити посилання DNS конфігурації NGINX. Особисто я вважаю, що це трохи менш інтуїтивно зрозуміле, але разом із ним приходить потужність. Compose може створювати додаткові екземпляри контейнерів, якщо вони вам потрібні, отже, схема імен екземплярів. Пам’ятайте, що ці зміни назв екземплярів означають, що будь-які команди, до яких ви звикли до цього часу, повинні бути змінені, як-от docker exec або docker cp для посилання на конкретні екземпляри. 

Для власного повчання ви також повинні поглянути на те, що Compose зробив для ваших томів і мереж. Не соромтеся виконувати такі команди:

    docker network ls
    docker volume ls

# ============================== 
При запуску контейнера Nginx після виконання команди docker-compose -p jenkins ps він вийшов із стану запущеного (Exited) з кодом виходу 1. Це може означати, що під час запуску виникла помилка. 

Треба переконатися, що конфігураційний файл Nginx налаштований правильно та не містить синтаксичних помилок. Також, перевірти журнал контейнера Nginx.

Перевірка журналу контейнера Nginx дав такий результат:

    docker logs (назва контейнера)

nginx: [emerg] invalid number of arguments in "proxy_pass" directive in /etc/nginx/conf.d/jenkins.conf:10
nginx: [emerg] invalid number of arguments in "proxy_pass" directive in /etc/nginx/conf.d/jenkins.conf:10

Помилка що ми бачемо говорить про те, що є невірна кількість аргументів в директиві proxy_pass у файлі конфігурації Nginx /etc/nginx/conf.d/jenkins.conf на рядку 10.

Приклад правильного синтаксису для директиви proxy_pass виглядає наступним чином:

    proxy_pass http://backend;

Виправляємо помилку та перевіряю процездатність контейнера.

Переконуємся що образи побудовані з останніми змінами, використовуємо опцію --build разом з командою docker-compose up:

    docker-compose -p jenkins up -d --build

# ============================== 

КРОК 6. ОБСЛУГОВУВАННЯ ЗА ДОПОМОГОЮ COMPOSE

Compose достатньо розумний, щоб знати про обсяг ваших даних і зберігати їх. Спробуйте це:

    Створіть тестове завдання у своєму екземплярі Jenkins (http://localhost). Не те, що вам, можливо, доведеться знову налаштувати сторінку адміністратора за допомогою пароля. Пам’ятайте, що назви екземплярів тепер змінено!
    docker-compose -p jenkins down
    Зробіть просте редагування головного докер-файлу Jenkins, наприклад змінивши ім’я супроводжуючого LABEL, і збережіть його.
    збірка docker-compose
    docker-compose -p jenkins up -d
    Поверніться до екземпляра Jenkins і зверніть увагу, що ваше тестове завдання все ще там.


